<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>StockTickerServer</name></assembly>
<members>
<member name="T:StockTicker.HttpRoute">
<summary>
 Route for ASP.NET Web API applications
</summary>
</member>
<member name="T:StockTicker.Logging.CombiningTarget">
<summary>
 A logger to use for combining a number of other loggers
</summary>
</member>
<member name="M:StockTicker.Logging.LiterateConsoleTarget.#ctor(System.String[],StockTicker.Logging.LogLevel,System.String,Microsoft.FSharp.Core.FSharpOption{StockTicker.Logging.Literate.LiterateOptions},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.ConsoleColor}},Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Object})">
<summary>
 Creates the target with a custom output template. The default `outputTemplate`
 is `[{timestampLocal:HH:mm:ss} {level}] {message}{exceptions}`.
 Available template fields are: `timestamp`, `timestampUtc`, `level`, `source`,
 `newline`, `tab`, `message`, `exceptions`. Any misspelled or otheriwese invalid property
 names will be treated as `LiterateToken.MissingTemplateField`.
</summary>
</member>
<member name="T:StockTicker.Logging.LiterateConsoleTarget">
<summary>
 Logs a line in a format that is great for human consumption,
 using console colours to enhance readability.
 Sample: [10:30:49 INF] User &quot;AdamC&quot; began the &quot;checkout&quot; process with 100 cart items
</summary>
</member>
<member name="P:StockTicker.Logging.LoggingConfig.consoleSemaphore">
<summary>
 When composing apps from the outside-in (rather than having a unified
 framework with static/global config) with libraries (again, rather than
 a unified framework) like is best-practice, there&apos;s not necessarily a
 way to coordinate around the STDOUT and STDERR streams between
 different libraries running things on different threads. Use Logary&apos;s
 adapter to replace this semaphore with a global semaphore.
</summary>
</member>
<member name="P:StockTicker.Logging.LoggingConfig.getLogger">
<summary>
 The `getLogger` function returns a logger that directly can be logged to.
</summary>
</member>
<member name="P:StockTicker.Logging.LoggingConfig.timestamp">
<summary>
 The `timestamp` function should preferably be monotonic and not &apos;jumpy&apos;
 or take much time to call.
</summary>
</member>
<member name="M:StockTicker.Logging.Logger.logWithAck(StockTicker.Logging.LogLevel,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Logs with the specified log level with backpressure via the logging
 library&apos;s buffers *and* ACK/flush to the underlying message targets.

 Calls to this function will block the caller only while executing the
 callback (if the level is active).

 The returned async value will yield when the message has been flushed to
 the underlying message targets.

 You need to start the (cold) async value for the logging to happen.

 You should not do blocking/heavy operations in the callback.
</summary>
</member>
<member name="M:StockTicker.Logging.Logger.log(StockTicker.Logging.LogLevel,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Logs with the specified log level with backpressure via the logging
 library&apos;s buffers.

 Calls to this function will block the caller only while executing the
 callback (if the level is active).

 The returned async value will yield when the message has been added to
 the buffers of the logging library.

 You need to start the (cold) async value for the logging to happen.

 You should not do blocking/heavy operations in the callback.
</summary>
</member>
<member name="P:StockTicker.Logging.Logger.name">
<summary>
 Gets the name of the logger instance.
</summary>
</member>
<member name="T:StockTicker.Logging.Logger">
<summary>
 The logger is the interface for calling code to use for logging. Its
 different functions have different semantics - read the docs for each
 method to choose the right one for your use-case.
</summary>
</member>
<member name="P:StockTicker.Logging.Message.level">
<summary>
 How important? See the docs on the LogLevel type for details.
</summary>
</member>
<member name="P:StockTicker.Logging.Message.timestamp">
<summary>
 When? nanoseconds since UNIX epoch.
</summary>
</member>
<member name="P:StockTicker.Logging.Message.fields">
<summary>
 The structured-logging data.
</summary>
</member>
<member name="P:StockTicker.Logging.Message.value">
<summary>
 The main value for this metric or event. Either a Gauge or an Event. (A
 discriminated union type)
</summary>
</member>
<member name="P:StockTicker.Logging.Message.name">
<summary>
 The &apos;path&apos; or &apos;name&apos; of this data point. Do not confuse template in
 (Event template) = message.value
</summary>
</member>
<member name="P:StockTicker.Logging.Message.utcTicks">
<summary>
 Gets the ticks for UTC since 0001-01-01 00:00:00 for this message. You
 can pass this value into a DateTimeOffset c&apos;tor
</summary>
</member>
<member name="P:StockTicker.Logging.Message.README">
<summary>
 If you&apos;re looking for how to transform the Message&apos;s fields, then use the
 module methods rather than instance methods, since you&apos;ll be creating new
 values rather than changing an existing value.
</summary>
</member>
<member name="T:StockTicker.Logging.Message">
<summary>
 This is record that is logged. It&apos;s capable of representing both metrics
 (gauges) and events. See https://github.com/logary/logary for details.
</summary>
</member>
<member name="T:StockTicker.Logging.EpochNanoSeconds">
<summary>
 The # of nanoseconds after 1970-01-01 00:00:00.
</summary>
</member>
<member name="T:StockTicker.Logging.PointValue.Gauge">
<summary>
 This is as value for a metric, with a unit attached. The unit can be
 something like Seconds or Hz.
</summary>
</member>
<member name="T:StockTicker.Logging.PointValue.Event">
<summary>
 An event is what it sounds like; something occurred and needs to be
 logged. Its field is named &apos;template&apos; because it should not be interpolated
 with values; instead these values should be put in the &apos;fields&apos; field of
 the Message.
</summary>
</member>
<member name="T:StockTicker.Logging.PointValue">
<summary>
 Represents a logged value; either a Gauge or an Event.
</summary>
</member>
<member name="T:StockTicker.Logging.LogLevel.Fatal">
<summary>
 The log message denotes a fatal error which cannot be recovered from. The
 service should be shut down. Human corrective action is needed.
</summary>
</member>
<member name="T:StockTicker.Logging.LogLevel.Error">
<summary>
 The log message is at an error level, meaning an unhandled exception
 occurred at a location where it is deemed important to keeping the service
 running. A human should take corrective action.
</summary>
</member>
<member name="T:StockTicker.Logging.LogLevel.Warn">
<summary>
 The log message is a warning; e.g. there was an unhandled exception or
 an even occurred which was unexpected. Sometimes human corrective action
 is needed.
</summary>
</member>
<member name="T:StockTicker.Logging.LogLevel.Info">
<summary>
 The log message is informational; e.g. the service started, stopped or
 some important business event occurred.
</summary>
</member>
<member name="T:StockTicker.Logging.LogLevel.Debug">
<summary>
 The log message is at a default level, debug level. Useful for shipping to
 infrastructure that further processes it, but not so useful for human
 inspection in its raw format, except during development.
</summary>
</member>
<member name="T:StockTicker.Logging.LogLevel.Verbose">
<summary>
 The log message is not that important; can be used for intricate debugging.
</summary>
</member>
<member name="M:StockTicker.Logging.LogLevel.toInt">
<summary>
 Turn the LogLevel into an integer
</summary>
</member>
<member name="M:StockTicker.Logging.LogLevel.ofString(System.String)">
<summary>
 Converts the string passed to a Loglevel.
</summary>
</member>
<member name="M:StockTicker.Logging.LogLevel.ofInt(System.Int32)">
<summary>
 Turn an integer into a LogLevel
</summary>
</member>
<member name="M:StockTicker.Logging.LogLevel.ToString">
<summary>
 Converts the LogLevel to a string
</summary>
</member>
<member name="T:StockTicker.Logging.LogLevel">
<summary>
 The log level denotes how &apos;important&apos; the gauge or event message is.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.addExn``1(``0,StockTicker.Logging.Message)">
<summary>
 Adds an exception to the Message, to the &apos;errors&apos; field, inside a list.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.setLevel(StockTicker.Logging.LogLevel,StockTicker.Logging.Message)">
<summary>
 Sets the level on the log message.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.setTimestamp(System.Int64,StockTicker.Logging.Message)">
<summary>
 Sets the timestamp on the log message.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.setFieldValue``1">
<summary>
 Alias to `setField`
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.setField(System.String,System.Object,StockTicker.Logging.Message)">
<summary>
 Sets the value of the field on the log message.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.setSingleName(System.String,StockTicker.Logging.Message)">
<summary>
 Sets the name as a single string; if this string contains dots, the string
 will be split on these dots.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.setNameEnding(System.String,StockTicker.Logging.Message)">
<summary>
 Sets the final portion o fthe name of the Message.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.setName(System.String[],StockTicker.Logging.Message)">
<summary>
 Sets the name/path of the log message.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.gauge(System.Int64,System.String)">
<summary>
 Create a new instantaneous value in a log message.
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.eventX(System.String,StockTicker.Logging.LogLevel)">
<summary>
 Create a new event log message – like `event` but with parameters flipped.
 Useful to use with `Logger.log` with point-free style, to reduce the
 noise. E.g. `logger.logVerbose (eventX &quot;Returned {code}&quot; &gt;&gt; setField &quot;code&quot; 24)`
</summary>
</member>
<member name="M:StockTicker.Logging.MessageModule.event(StockTicker.Logging.LogLevel,System.String)">
<summary>
 Create a new event log message.
</summary>
</member>
<member name="T:StockTicker.Logging.MessageModule">
<summary>
 The Message module contains functions that can help callers compose messages. This
 module is especially helpful to open to make calls into Logary&apos;s facade small.
</summary>
</member>
<member name="M:StockTicker.Logging.Log.createHiera(System.String[])">
<summary>
 Create an hierarchically named logger
</summary>
</member>
<member name="M:StockTicker.Logging.Log.create(System.String)">
<summary>
 Create a named logger. Full stop (.) acts as segment delimiter in the
 hierachy of namespaces and loggers.
</summary>
</member>
<member name="T:StockTicker.Logging.Log">
<summary>
 Module for acquiring static loggers (when you don&apos;t want or can&apos;t)
 pass loggers as values.
</summary>
</member>
<member name="M:StockTicker.Logging.Targets.create(StockTicker.Logging.LogLevel,System.String[])">
<summary>
 Create a new target. Prefer `Log.create` in your own libraries, or let the
 composing app replace your target instance through your configuration.

 Will log to console (colourised) by default, and also to the output window
 in your IDE if you specify a level below Info.
</summary>
</member>
<member name="T:StockTicker.Logging.Targets">
<summary>
 &quot;Shortcut&quot; for creating targets; useful at the top-level configuration point of
 your library.
</summary>
</member>
<member name="T:StockTicker.Logging.Global.Flyweight">
<summary>
 The flyweight just references the current configuration. If you want
 multiple per-process logging setups, then don&apos;t use the static methods,
 but instead pass a Logger instance around, setting the name field of the
 Message value you pass into the logger.
</summary>
</member>
<member name="M:StockTicker.Logging.Global.initialise(StockTicker.Logging.LoggingConfig)">
<summary>
 Call from the initialisation of your library. Initialises the
 Logary.Facade globally/per process.
</summary>
</member>
<member name="M:StockTicker.Logging.Global.lockSem``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Run the passed function under the console semaphore lock.
</summary>
</member>
<member name="M:StockTicker.Logging.Global.semaphore">
<summary>
 Returns the synchronisation object to use when printing to the console.
</summary>
</member>
<member name="P:StockTicker.Logging.Global.defaultConfig">
<summary>
 The global default configuration, which logs to Console at Info level.
</summary>
</member>
<member name="P:StockTicker.Logging.Global.consoleSemaphore">
<summary>
 This is the global semaphore for colourising the console output. Ensure
 that the same semaphore is used across libraries by using the Logary
 Facade Adapter in the final composing app/service.
</summary>
</member>
<member name="M:StockTicker.Logging.LiterateFormatting.tokeniserForOutputTemplate(System.String)">
<summary>
 Creates a `LiterateTokeniser` function which can be passed to the `LiterateConsoleTarget`
 constructor in order to customise how each log message is rendered. The default template
 would be: `[{timestampLocal:HH:mm:ss} {level}] {message}{newline}{exceptions}`.
 Available template fields are: `timestamp`, `timestampUtc`, `level`, `source`,
 `newline`, `tab`, `message`, `exceptions`. Any misspelled or otheriwese invalid property
 names will be treated as `LiterateToken.MissingTemplateField`. 
</summary>
</member>
<member name="T:StockTicker.Logging.LiterateFormatting">
<summary>
 Assists with controlling the output of the `LiterateConsoleTarget`.
</summary>
</member>
<member name="M:StockTicker.Logging.Formatting.defaultFormatter(StockTicker.Logging.Message)">
<summary>
 let the ISO8601 love flow
</summary>
</member>
<member name="M:StockTicker.Logging.Formatting.literateDefaultTokeniser(StockTicker.Logging.Literate.LiterateOptions,StockTicker.Logging.Message)">
<summary>
 Split a structured message up into theme-able parts (tokens), allowing the
 final output to display to a user with colours to enhance readability.
</summary>
</member>
<member name="T:StockTicker.Logging.Formatting">
<summary>
 Internal module for formatting text for printing to the console.
</summary>
</member>
<member name="M:StockTicker.Logging.FsMtParser.parseParts(System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.FsMtParser.Property,Microsoft.FSharp.Core.Unit})">
<summary>
 Parses template strings such as &quot;Hello, {PropertyWithFormat:##.##}&quot;
 and calls the &apos;foundTextF&apos; or &apos;foundPropF&apos; functions as the text or
 property tokens are encountered.
</summary>
</member>
<member name="P:StockTicker.Logging.Literals.FacadeLanguage">
<summary>
 What language this Facade has. This controls things like naming standards.
</summary>
</member>
<member name="P:StockTicker.Logging.Literals.FacadeVersion">
<summary>
 What version of the Facade is this. This is a major version that allows the Facade
 adapter to choose how it handles the API.
</summary>
</member>
<member name="T:StockTicker.Logging.Literals">
<summary>
 Module that contains the &apos;known&apos; keys of the Maps in the Message type&apos;s
 fields/runtime data.
</summary>
</member>
<member name="T:StockTicker.Logging.Literate.LiterateToken">
<summary>
 The output tokens, which can be potentially coloured.
</summary>
</member>
<member name="M:StockTicker.Logging.LoggerEx.Logger.logSimple(StockTicker.Logging.Logger,StockTicker.Logging.Message)">
<summary>
 Log a message, but don&apos;t synchronously wait for the message to be placed
 inside the logging library&apos;s buffers. Instead the message will be added
 to the logging library&apos;s buffers asynchronously (with respect to the
 caller) with a timeout of 5 seconds, and will then be dropped.

 This is the way we avoid the unbounded buffer problem.

 If you have dropped messages, they will be logged to STDERR. You should load-
 test your app to ensure that your targets can send at a rate high enough
 without dropping messages.

 It&apos;s recommended to have alerting on STDERR.
</summary>
</member>
<member name="M:StockTicker.Logging.LoggerEx.Logger.fatalWithBP(StockTicker.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:StockTicker.Logging.LoggerEx.Logger.errorWithBP(StockTicker.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:StockTicker.Logging.LoggerEx.Logger.warnWithBP(StockTicker.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:StockTicker.Logging.LoggerEx.Logger.infoWithBP(StockTicker.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:StockTicker.Logging.LoggerEx.Logger.debugWithBP(StockTicker.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:StockTicker.Logging.LoggerEx.Logger.verboseWithBP(StockTicker.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{StockTicker.Logging.LogLevel,StockTicker.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="T:StockTicker.Logging.LoggerEx">
<summary>
 Syntactic sugar on top of Logger for F# libraries.
</summary>
</member>
<member name="M:StockTicker.Logging.DateTimeOffset.ticksUTC(System.Int64)">
<summary>
 Get the DateTimeOffset ticks from EpochNanoSeconds
</summary>
</member>
<member name="M:StockTicker.Logging.DateTimeOffset.timestamp(System.DateTimeOffset)">
<summary>
 Get the Logary timestamp off the DateTimeOffset.
</summary>
</member>
<member name="T:StockTicker.Logging.DateTimeOffset">
<summary>
 Helper functions for transforming DateTimeOffset to timestamps in unix epoch.
</summary>
</member>
<member name="M:StockTicker.Logging.DateTime.ticksUTC(System.Int64)">
<summary>
 Get the DateTimeOffset ticks off from the EpochNanoSeconds.
</summary>
</member>
<member name="M:StockTicker.Logging.DateTime.timestamp(System.DateTime)">
<summary>
 Get the Logary timestamp off the DateTime.
</summary>
</member>
<member name="T:StockTicker.Logging.DateTime">
<summary>
 Helper functions for transforming DateTime to timestamps in unix epoch.
</summary>
</member>
<member name="T:StockTicker.Events.EventStorage.EventStorage">
<summary>
 Custom implementation of in-memory time async event storage. Using message passing.
</summary>
</member>
<member name="M:StockTicker.Events.EventBus.Subscribe(Microsoft.FSharp.Core.FSharpFunc{StockTicker.Events.Events.Event,Microsoft.FSharp.Core.Unit})">
<summary>
 Used to subscribe to event changes
</summary>
</member>
<member name="P:StockTicker.Events.EventBus.EventPublisher">
<summary>
 Used just to notify others if anyone would be interested
</summary>
</member>
<member name="T:StockTicker.Events.EventBus">
<summary>
 Event broker for event based communication
</summary>
</member>
</members>
</doc>
